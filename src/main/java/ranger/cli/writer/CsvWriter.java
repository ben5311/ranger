package ranger.cli.writer;

import com.google.gson.Gson;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.lang3.ClassUtils;
import ranger.util.GsonSerializer;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;

import static ranger.cli.Constants.CSV_FORMAT_DEFAULT;
import static ranger.cli.Constants.EXTENSION_CSV;

/**
 * Writer designed to write multiple Objects generated by ObjectGenerator into a CSV file.
 * It automatically prints header names if not appending to an existing file.
 * It infers header names from first Map object supplied to writeObject()
 */
public class CsvWriter extends OutputWriter {

    private String filename;
    private final CSVPrinter printer;
    private final Gson gson;
    private boolean firstWrite = true;
    private final boolean printHeader;

    public CsvWriter(String filename, Charset charset) throws IOException {
        this(filename, charset, false);
    }

    public CsvWriter(String filename, Charset charset, boolean append) throws IOException {
        this(filename, charset, append, CSV_FORMAT_DEFAULT);
    }

    public CsvWriter(String filename, Charset charset, boolean append, CSVFormat format) throws IOException {
        this.filename = Objects.requireNonNull(filename);
        Objects.requireNonNull(format);
        File file = new File(filename + EXTENSION_CSV);
        if (!file.exists() && file.toPath().getParent() != null) {
            Files.createDirectories(file.toPath().getParent());
        }
        this.printer = new CSVPrinter(
                new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, append), charset)), format);
        this.gson = GsonSerializer.newGsonInstance();
        this.printHeader = !(file.exists() && append);
    }

    public CsvWriter(Writer writer, CSVFormat format) throws IOException {
        this.printer = new CSVPrinter(writer, format);
        this.gson = GsonSerializer.newGsonInstance();
        this.printHeader = true;
    }

    @SuppressWarnings("unchecked")
    @Override
    /*
     * Writes object to CSV file.
     * If object is instance of Map, the function automatically extracts the CSV header out of first written object.
     */
    public synchronized CsvWriter writeObject(Object entry) throws IOException {
        if (entry instanceof Map) {
            Map<Object, Object> map = (Map<Object, Object>) entry;
            if (firstWrite && printHeader) {
                writeRecord(map.keySet());     //add header
                firstWrite = false;
            }
            writeRecord(map.values());
        } else {    //entry is single object
            if (firstWrite && printHeader) {
                if (filename != null) {
                    writeRecord(Collections.singletonList(new File(filename).getName()));   //add header
                }
                firstWrite = false;
            }
            writeRecord(Collections.singletonList(entry));
        }
        return this;
    }

    private void writeRecord(Iterable<Object> entry) throws IOException {
        Objects.requireNonNull(entry);
        for (Object value : entry) {
            if (ClassUtils.isPrimitiveOrWrapper(value.getClass())) {     // value is primitive
                printer.print(value);
            } else {    //value is other Object like Date, Map, List, so serialize with Gson
                String jsonValue = gson.toJson(value);
                if (jsonValue.startsWith("\"") && jsonValue.endsWith("\"")) {
                    jsonValue = jsonValue.substring(1, jsonValue.length() - 1);
                }
                printer.print(jsonValue);
            }
        }
        printer.println();
    }

    @Override
    public void flush() throws IOException {
        printer.flush();
    }

    @Override
    public void close() throws IOException {
        printer.close(true);
    }

}
